# 기초

## 알고리즘이란

- 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어 내는 과정.
- 정확성과 효율성이 중요하다.
- 잘 설계된 알고리즘은 명확하고 효율적이어야 한다.
- 알고리즘이 명확하다는 것은 모호하지 않고 이해하기 쉬움을 뜻한다.
- 점근적 접근법을 통해 하드웨어와 언어에 무관한 "좋은" 알고리즘이 무엇인지 알 수 있다.

## 알고리즘의 수행 시간

- 최악의 경우 또는 평균적인 경우에 대한 분석이 대표적으로 이루어진다.
  - 주어진 n개의 정수 중 특정 정수를 탐색하는 경우:
    - 선형 검색(Linear Search)는 최대 `n`번, 평균 `n/2`번의 시행을 요구한다.
    - 이진 탐색(Binary Search)는 최대 `Math.ceil(log~2~n)`의 시행을 요구한다.
- 입력의 크기 `n`에 비해 시간이 어떤 비율로 소요되는지로 표현한다.
  - 배열 A에서, A의 원소가 홀수 개라면 A의 가운데 값, 짝수 개라면 그 다음 값을 구하는 경우
    ```
    function(A){
        n = A.length
        k = n%2? Math.ceil(n/2) - 1 : n/2
        return A[k]
    }
    ```
    배열의 크기에 관계 없이 상수 시간이 소요된다.
  - 배열 A[1,2,..,n]의 모든 원소를 더하는 경우
    ```javascript
    function(A){
        let sum = 0;
        for(let i = 0; i<A.length; i++){
            sum++;
        }
        return sum
    }
    ```
    - for 루프를 제외한 부분은 상수 시간이 소요되므로, for루프가 시간을 결정한다.
      - for 루프는 n번 반복된다.
      - 각 루프에서는 단순한 덧셈만 하므로 상수 시간이 소요된다.
      - 따라서, for루프 수행시간은 n에 비례한다.
    - 알고리즘의 수행시간은 n에 비례한다.
  - for 루프가 중첩되는 경우
    ```javascript
    function(A){
        let sum = 0;
        for(let i = 0; i<A.length; i++){
            for(let j = 0; j<A.length; j++){
                sum = sum+A[i]*A[j]
            }
        }
        return sum
    }
    ```
    - for 루프가 총 n\*n번 반복된다.
      - 각 루프에서는 덧셈 한 번, 곱셈 한 번이 수행된다. (=상수 시간이 소요된다.)
    - 알고리즘의 수행시간은 n^2^에 비례한다.
  - for 루프를 n^2^번 반복하면서 배열에서 반을 임의로 뽑아 그 중 최대값을 더하는 경우
    ```javascript
    function(A){
        let sum = 0;
        const n = A.length
        for(let i = 0; i<n; i++){
            for(let j = 0; j<n; j++){
                let max = 0;
                for(let k=0; k<n/2; k++){
                    const num = parseInt(Math.random()*(n-1));
                    max = max > num ? max : num;
                }
                sum = sum + max;
            }
        }
        return sum
    }
    ```
    - 반을 임의로 뽑아 최대값을 구하는 것은 n/2에 비례하는 시간이 든다.
      - 이것은 n에 비례하는 시간이다.
    - 총 수행시간은 n^3^에 비례한다.
  - 배열 A[1,2,...,n]에서 i < j 인 모든 원소쌍의 곱을 합산할 경우
    ```javascript
        function(A){
            let sum = 0;
            for(i=0; i<A.length-1; i++){
                for(j=i+1; j<A.length; j++){
                    sum = sum + A[i]*A[j];
                }
            }
            return sum
        }
    ```
    - 가장 안쪽 for 루프는 상수 시간을 소요한다.
    - 안쪽 for 루프는 n-1, n-2, n-3, ... 1회 반복된다.
    - for 루프의 총 반복횟수는 (n-1)+(n-2)+...+1 = n(n-1)/2로, n^2^에 비례한다.
    - 총 수행시간은 n^2^에 비례한다.

## 자기호출

- 자기호출(재귀)의 경우 앞선 단순 산술과는 다른 시간이 소요된다.

```javascript
    function(n){
        if(n=1) return 1;
        return n*function(n-1);
    }

```

- 이 경우, 알고리즘의 총 수행시간은 n에 비례한다.

- 자기호출은 수학적 귀납법과 관련이 깊다.
  - 수학적 귀납법이란 자신보다 작은 문제에 대해 결론이 옳음을 가정하고 자신과 작은 문제와의 관계를 통해 자신에 대해서도 결론이 옳음을 보이는 것이다.
  - 자기호출은 자신보다 작은 문제에 대해 알고리즘이 제대로 작동한다고 가정하는 것이다.
- 병합정렬

## 경로 찾기 알고리즘

미로의 특정 칸에서 시작한 캐릭터가 출구를 찾는 최단거리를 구하시오.
단, 캐릭터는 상하좌우로만 움직일 수 있다.

- 미로의 출구에 비용 0을 할당한다.
- 움직일 수 있는 칸, 즉 상하좌우로 1칸 떨어져 있으며 비어있는(벽이 없는) 칸에 1을 할당한다.
- 1이 할당된 칸에서 움직일 수 있는 칸에 2를 할당한다. 0이 할당된 칸에는 비용을 다시 할당하지 않는다.
- 이와 같이 k가 할당된 칸에서 k 이하의 수가 할당되지 않은 이동가능한 칸에 k+1을 할당한다.
- 캐릭터가 놓여져 있는 출발지점까지 비용을 할당한다.
- 비용이 1만큼 줄어드는 방향으로 캐릭터를 움직인다.
